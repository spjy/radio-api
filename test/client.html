<html>
  <body>
    oh hey there
    <pre id="outgoing"></pre>
    <script src="simple-peer.min.js"></script>
    <script>
      /**
       * initiator generates an offer in 'signal'
       * send the offer through socket to all other clients. (initiator ignores offer)
       * receiver passes offer to signal()
       * receiver generates answer in 'signal'
       * receiver sends answer through socket to client that generated the offer
       * initiator receives answer and passes it into signal()
       * Connection!
       */

       /**
        * Get client count - 1 (to exclude self)
        * Create client count - 1 number of initiators
        * 
        */
      const userId = Math.random()
      const ws = new WebSocket('ws://localhost:8081');

      // Inititator client instances for initially connect
      const origin = {};
      // Receiver client instances for connecting to newer initiator client instances
      const incoming = {};

      // SDP storages to avoid connecting to oneself
      let initiatorSdps = [];
      let receiverSdps = [];

      // Reusable initiator code
      function initiator() {
        const initiator = new SimplePeer({ initiator: true, trickle: false });

        initiator.on('error', err => console.log('error', err));

        initiator.on('signal', data => {
          console.log('SIGNAL', data);
          // Get SDP from initial construction
          if (!initiatorSdps.includes(data.sdp) && data.type === 'offer') {
            // save 
            initiatorSdps.push(data.sdp);
            console.log(initiatorSdps)
            // Send offer to other clients over socket
            ws.send(JSON.stringify({
              type: 'connection',
              payload: {
                id: userId,
                connection: data
              }
            }));
          }
        });

        // Function run upon successfully connecting to peer
        initiator.on('connect', () => {
          console.log('CONNECT')
          setInterval(() => {
            console.log('sent from initiator');
            initiator.send('sent from initiator ' + initiator._id)
          }, 3000)
        });

        // Function run upon receiving data from peer
        initiator.on('data', data => {
          console.log('data: ' + data)
        });

        // Function run upon closing connection with peer
        initiator.on('close', () => {
          console.log('initiator disconnected')
          initiator.destroy()
          delete origin[initiator._id];
        });

        return initiator;
      }

      // Reusable receiver code
      function receiver({ id, connection }) {
        const receiver = new SimplePeer({ initiator: false, trickle: false });

        console.log(id, connection)

        receiver.signal(connection);

        receiver.on('error', err => console.log('error', err))

        receiver.on('signal', data => {
          if (!receiverSdps.includes(data.sdp) && data.type === 'answer') {
            console.log('RECEIVER SIG', data)
            receiverSdps.push(data.sdp)

            ws.send(JSON.stringify({
              type: 'connection',
              payload: {
                id,
                connection: data
              }
            }));
          }
        });

        receiver.on('connect', () => {
          console.log('CONNECT')
          setInterval(() => {
            console.log('sent from receiver');
            receiver.send('send from receive ' + receiver._id)
          }, 3000)
        });

        receiver.on('data', data => {
          console.log('data: ' + data)
        });

        receiver.on('close', () => {
          console.log('receiver disconnected')
          receiver.destroy()
          delete incoming[receiver._id];
        });

        return receiver;
      }

      ws.addEventListener('open', () => {
        console.log('OPEN')
        ws.send(JSON.stringify({
          type: 'clientCount'
        }));
      });

      ws.addEventListener('message', ({ data }) => {
        try {
          const json = JSON.parse(data);

          switch (json.type) {
            case 'connection': {
              // Accept offer and make answer
              switch (json.payload.connection.type) {
                // Initiating a connection between self and another client
                case 'offer': {
                  if (!initiatorSdps.includes(json.payload.connection.sdp) && !Object.keys(incoming).includes(json.payload.id)) {
                    // Create a receiver instance to connect to offer
                    const receiverInstance = receiver(json.payload);
                    incoming[json.payload.id] = receiverInstance;
                  }
                  break;
                }
                case 'answer':
                  if (!receiverSdps.includes(json.payload.connection.sdp) && json.payload.id === userId) {
                    // Find an initiator that has not been used yet and complete the connection
                    for (initiator in origin) {
                      if (!origin[initiator].answered) {
                        origin[initiator].instance.signal(json.payload.connection);
                        origin[initiator].answered = true;
                        break;
                      }
                    }
                  }
                  break;
                default:
                  break;
              }
              break;
            }
            case 'clientCount': {
              // Create initiators based on the amount of clients already connected. Exclude self.
              for (let i = 0; i < json.payload - 1; i = i + 1) {
                const initiatorInstance = initiator();

                // Store initiator instance into map
                origin[initiatorInstance._id] = {
                  instance: initiatorInstance,
                  answered: false
                };
              }
              break;
            }
            default:
              break;
          }
        } catch (err) {
          console.error(err);
        }
      });
    </script>
  </body>
</html>
